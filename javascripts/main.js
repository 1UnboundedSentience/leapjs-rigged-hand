// Generated by CoffeeScript 1.6.3
(function() {
  var HEIGHT, WIDTH, animation, axis, cameraPosition, cameraPositions, handMesh, pointLight, renderer, scene, text, visualizeBone, visualizeBones;

  HEIGHT = window.innerHeight;

  WIDTH = window.innerWidth;

  scene = new THREE.Scene();

  renderer = new THREE.WebGLRenderer({
    alpha: true
  });

  renderer.setClearColor(0x000000, 1);

  renderer.setSize(WIDTH, HEIGHT);

  document.getElementById('threejs').appendChild(renderer.domElement);

  axis = new THREE.AxisHelper(5);

  scene.add(axis);

  scene.add(new THREE.AmbientLight(0x888888));

  pointLight = new THREE.PointLight(0xFFffff);

  pointLight.position = new THREE.Vector3(-20, 10, 0);

  pointLight.lookAt(new THREE.Vector3(0, 0, 0));

  scene.add(pointLight);

  window.camera = new THREE.PerspectiveCamera(90, WIDTH / HEIGHT, 1, 1000);

  cameraPositions = {
    back: [0, 0, -10],
    front: [0, 3, 15],
    rightSide: [25, 0, 0],
    top: [0, 14, 0]
  };

  cameraPosition = 'top';

  renderer.domElement.onclick = function() {
    camera.position.fromArray(cameraPositions[cameraPosition]);
    camera.lookAt(new THREE.Vector3(0, 0, 0));
    if (cameraPosition === 'front') {
      cameraPosition = 'back';
    } else {
      cameraPosition = 'front';
    }
    return renderer.render(scene, camera);
  };

  renderer.domElement.click();

  scene.add(camera);

  animation = void 0;

  handMesh = void 0;

  text = new THREE.Mesh(new THREE.TextGeometry('Y AXIS', {
    size: 0.5,
    height: 0.2
  }), new THREE.MeshBasicMaterial({
    color: 0xffffff
  }));

  text.position.x = axis.geometry.vertices[1].x;

  text.position.y = axis.geometry.vertices[1].y;

  text.position.z = axis.geometry.vertices[1].z;

  text.rotation = camera.rotation;

  scene.add(text);

  visualizeBones = function(whichMesh) {
    var child, _i, _len, _ref, _results;
    _ref = whichMesh.children;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      _results.push(visualizeBone(child, whichMesh));
    }
    return _results;
  };

  visualizeBone = function(bone, parentMesh) {
    var child, length, m, _i, _len, _ref, _results;
    length = bone.children[0] ? bone.children[0].position.length() : 0.2;
    console.log(bone.name, length);
    m = new THREE.Mesh(new THREE.CubeGeometry(.4, .2, length), new THREE.MeshPhongMaterial({
      color: 0x00ff00
    }));
    parentMesh.add(m);
    m.position = bone.position;
    m.quaternion = bone.quaternion;
    parentMesh.add(new THREE.AxisHelper(1));
    _ref = bone.children;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      _results.push(visualizeBone(child, m));
    }
    return _results;
  };

  (new THREE.JSONLoader).load('javascripts/14right.json', function(geometryWithBones, materials) {
    var armVector, material, rigFinger, _i, _len, _ref;
    material = materials[0];
    material.skinning = true;
    material.wireframe = true;
    handMesh = new THREE.SkinnedMesh(geometryWithBones, material);
    handMesh.castShadow = true;
    handMesh.receiveShadow = true;
    visualizeBones(handMesh);
    scene.add(handMesh);
    window.palm = handMesh.children[0].children[0].children[0];
    window.thumb = palm.children[0];
    window.indexFinger = palm.children[1];
    window.middleFinger = palm.children[2];
    window.ringFinger = palm.children[3];
    window.pinky = palm.children[4];
    thumb.localAxisLevel = (new THREE.Vector3(0, 0, 1)).visualize(scene, 0x0000ff);
    armVector = (new THREE.Vector3(1, 0, 2)).normalize();
    armVector.multiplyScalar(10);
    _ref = palm.children;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      rigFinger = _ref[_i];
      rigFinger.mip = rigFinger.children[0];
      rigFinger.dip = rigFinger.children[0].children[0];
      rigFinger.worldDirection = new THREE.Vector3;
      rigFinger.mip.worldDirection = new THREE.Vector3;
      rigFinger.dip.worldDirection = new THREE.Vector3;
      rigFinger.worldUp = new THREE.Vector3;
      rigFinger.mip.worldUp = new THREE.Vector3;
      rigFinger.dip.worldUp = new THREE.Vector3;
      rigFinger.worldAxis = new THREE.Vector3;
      rigFinger.mip.worldAxis = new THREE.Vector3;
      rigFinger.dip.worldAxis = new THREE.Vector3;
      rigFinger.worldAxisReverse = new THREE.Vector3(0, 0, 1);
      rigFinger.mip.worldAxisReverse = new THREE.Vector3(0, 0, 1);
      rigFinger.dip.worldAxisReverse = new THREE.Vector3(0, 0, 1);
    }
    palm.worldUp = (new THREE.Vector3).visualize(palm, 0xff0000);
    palm.worldDirection = (new THREE.Vector3).visualize(palm, 0xffff00);
    renderer.render(scene, camera);
    thumb.localAxis = vec3(0, 0, 0).normalize();
    thumb.mip.localAxis = vec3(1, 0, 0).normalize();
    thumb.dip.localAxis = vec3(1, 0, 0).normalize();
    indexFinger.localAxis = vec3(1, 0, -0.2).normalize();
    indexFinger.mip.localAxis = vec3(1, 0, -0.2).normalize();
    indexFinger.dip.localAxis = vec3(1, 0, -0.2).normalize();
    middleFinger.localAxis = vec3(1, 0, 0).normalize();
    middleFinger.mip.localAxis = vec3(1, 0, 0).normalize();
    middleFinger.dip.localAxis = vec3(1, 0, 0).normalize();
    ringFinger.localAxis = vec3(1, 0, 0.1).normalize();
    ringFinger.mip.localAxis = vec3(1, 0, 0.1).normalize();
    ringFinger.dip.localAxis = vec3(1, 0, 0.1).normalize();
    pinky.localAxis = vec3(1, 0, 0.2).normalize();
    pinky.mip.localAxis = vec3(1, 0, 0.2).normalize();
    pinky.dip.localAxis = vec3(1, 0, 0.2).normalize();
    window.j = 0;
    return Leap.loop(function(frame) {
      var i, leapFinger, leapHand, _j, _len1, _ref1;
      if (leapHand = frame.hands[0]) {
        palm.worldDirection.fromArray(leapHand.direction);
        palm.worldUp.fromArray(leapHand.palmNormal).multiplyScalar(-1);
        palm.matrix.lookAt(palm.worldDirection, zeroVector, palm.worldUp);
        palm.matrix.decompose(palm.position, palm.quaternion, palm.scale);
        palm.updateMatrixWorld(true);
        _ref1 = leapHand.fingers;
        for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
          leapFinger = _ref1[i];
          if (i === 1) {
            palm.children[i].worldDirection.subVectors(leapFinger.pipPosition, leapFinger.mcpPosition).normalize();
            palm.children[i].mip.worldDirection.subVectors(leapFinger.dipPosition, leapFinger.pipPosition).normalize();
            palm.children[i].dip.worldDirection.subVectors(leapFinger.tipPosition, leapFinger.dipPosition).normalize();
            palm.children[i].positionFromWorld();
            palm.children[i].mip.positionFromWorld();
            palm.children[i].dip.positionFromWorld();
          }
        }
        palm.worldUp.visualize();
        palm.worldDirection.visualize();
        return renderer.render(scene, camera);
      }
    });
  });

}).call(this);
