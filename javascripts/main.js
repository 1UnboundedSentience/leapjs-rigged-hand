// Generated by CoffeeScript 1.6.3
(function() {
  var HEIGHT, TO_DEG, TO_RAD, WIDTH, animation, camera, handMesh, pointLight, redDot, renderer, scene, yellowDot, zeroVector;

  TO_RAD = Math.PI / 180;

  TO_DEG = 1 / TO_RAD;

  zeroVector = new THREE.Vector3(0, 0, 0);

  THREE.Quaternion.prototype.setFromPoints = function(a, b, c) {
    return this.setFromVectors((new THREE.Vector3).subVectors(a, b).normalize(), (new THREE.Vector3).subVectors(c, b).normalize());
  };

  THREE.Vector3.prototype.quick = function() {
    return [this.x.toPrecision(2), this.y.toPrecision(2), this.z.toPrecision(2)];
  };

  THREE.Bone.prototype.positionFromWorld = function() {
    var angle, directionDotParentDirection, localAxis, localAxisLevel, worldAxisLevel;
    directionDotParentDirection = this.worldDirection.dot(this.parent.worldDirection);
    angle = Math.acos(directionDotParentDirection);
    localAxisLevel = new THREE.Vector3(1, 0, 0);
    worldAxisLevel = (new THREE.Vector3).crossVectors(this.parent.worldUp, this.parent.worldDirection).normalize();
    this.worldAxis.crossVectors(this.parent.worldDirection, this.worldDirection).normalize();
    this.worldAxisReverse.crossVectors(this.worldDirection, this.parent.worldDirection).normalize();
    this.worldUp || (this.worldUp = new THREE.Vector3);
    this.worldUp.set(0, 0, 0).add(this.parent.worldUp.clone().multiplyScalar(directionDotParentDirection)).add((new THREE.Vector3).crossVectors(this.worldAxis, this.parent.worldUp).multiplyScalar(Math.sin(angle))).add(this.worldAxis.clone().multiplyScalar(this.worldAxis.dot(this.parent.worldUp) * (1 - directionDotParentDirection))).normalize();
    localAxis = localAxisLevel.add(worldAxisLevel).sub(this.worldAxis).normalize();
    this.quaternion.setFromAxisAngle(localAxis, angle);
    return this;
  };

  THREE.Vector3.prototype.visualize = function(scene, color) {
    if (this._arrow) {
      this._arrow.setDirection(this);
    } else {
      this._arrow = new THREE.ArrowHelper(this, new THREE.Vector3(-7, 0, 0), 10, color);
      scene.add(this._arrow);
    }
    return this;
  };

  THREE.Vector3.prototype.visualizeFrom = function(origin) {
    this._arrow.position.copy(origin);
    return this;
  };

  HEIGHT = window.innerHeight;

  WIDTH = window.innerWidth;

  scene = new THREE.Scene();

  renderer = new THREE.WebGLRenderer({
    alpha: true
  });

  renderer.setClearColor(0x000000, 1);

  renderer.setSize(WIDTH, HEIGHT);

  document.getElementById('threejs').appendChild(renderer.domElement);

  scene.add(new THREE.AxisHelper(50));

  scene.add(new THREE.AmbientLight(0x888888));

  pointLight = new THREE.PointLight(0xFFffff);

  pointLight.position = new THREE.Vector3(-20, 10, 0);

  pointLight.lookAt(new THREE.Vector3(0, 0, 0));

  scene.add(pointLight);

  redDot = new THREE.Mesh(new THREE.SphereGeometry(1), new THREE.MeshPhongMaterial({
    color: 0xff0000
  }));

  scene.add(redDot);

  yellowDot = new THREE.Mesh(new THREE.SphereGeometry(1), new THREE.MeshPhongMaterial({
    color: 0xcccc00
  }));

  scene.add(yellowDot);

  camera = new THREE.PerspectiveCamera(90, WIDTH / HEIGHT, 1, 1000);

  camera.position.set(0, 3, 15);

  camera.lookAt(new THREE.Vector3(0, 0, 0));

  scene.add(camera);

  animation = void 0;

  handMesh = void 0;

  function  visualizeBones( whichMesh , mesh ){
     for( var i = 0; i < whichMesh.bones.length; i++ ){
       var bone = whichMesh.bones[i];
       if( bone.parent == whichMesh ){
         visualizeBone( bone , whichMesh, mesh );
       }
     }
   }

   function visualizeBone( bone , parent , mesh ){
     var m = mesh.clone();
     parent.add( m );
     m.position = bone.position;
     m.rotation = bone.rotation;
     m.quaternion = bone.quaternion;

     for( var i = 0 ; i < bone.children.length; i ++ ){
       var childBone = bone.children[i];
       visualizeBone( childBone , m , mesh );
     }
   };

  (new THREE.JSONLoader).load('javascripts/14right.json', function(geometryWithBones, materials) {
    var armVector, bone, i, j, material, pos, rigFinger, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
    material = materials[0];
    material.skinning = true;
    _ref = geometryWithBones.bones;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      bone = _ref[_i];
      _ref1 = bone.pos;
      for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
        pos = _ref1[i];
        bone.pos[i] *= 100;
      }
    }
    THREE.GeometryUtils.center(geometryWithBones);
    handMesh = new THREE.SkinnedMesh(geometryWithBones, material);
    handMesh.castShadow = true;
    handMesh.receiveShadow = true;
    visualizeBones(handMesh, new THREE.Mesh(new THREE.IcosahedronGeometry(.5, 1), new THREE.MeshNormalMaterial()));
    scene.add(handMesh);
    window.forearm = handMesh.children[0];
    window.palm = handMesh.children[0].children[0].children[0];
    window.thumb = palm.children[0];
    window.indexFinger = palm.children[1];
    window.middleFinder = palm.children[2];
    window.ringFinger = palm.children[3];
    window.pinky = palm.children[4];
    palm.children = [thumb, indexFinger, middleFinder, ringFinger, pinky];
    forearm.matrixAutoUpdate = false;
    palm.worldUp = (new THREE.Vector3).visualize(scene, 0xff0000);
    palm.worldDirection = (new THREE.Vector3).visualize(scene, 0xffff00);
    armVector = (new THREE.Vector3(1, 0, 2)).normalize();
    armVector.multiplyScalar(10);
    _ref2 = palm.children;
    for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
      rigFinger = _ref2[_k];
      rigFinger.worldDirection = new THREE.Vector3;
      rigFinger.children[0].worldDirection = new THREE.Vector3;
      rigFinger.children[0].children[0].worldDirection = new THREE.Vector3;
      rigFinger.worldUp = new THREE.Vector3;
      rigFinger.children[0].worldUp = new THREE.Vector3;
      rigFinger.children[0].children[0].worldUp = new THREE.Vector3;
      rigFinger.worldAxis = (new THREE.Vector3).visualize(scene, 0x00ff00);
      rigFinger.children[0].worldAxis = new THREE.Vector3;
      rigFinger.children[0].children[0].worldAxis = new THREE.Vector3;
      rigFinger.worldAxisReverse = (new THREE.Vector3).visualize(scene, 0x00ff00);
      rigFinger.children[0].worldAxisReverse = new THREE.Vector3;
      rigFinger.children[0].children[0].worldAxisReverse = new THREE.Vector3;
    }
    indexFinger.worldUp.visualize(scene, 0x770000);
    indexFinger.worldDirection.visualize(scene, 0x777700);
    indexFinger.worldAxis.visualize(scene, 0x00ff00);
    renderer.render(scene, camera);
    j = 0;
    return Leap.loop(function(frame) {
      var leapFinger, leapHand, _l, _len3, _ref3;
      if (leapHand = frame.hands[0]) {
        redDot.position.fromArray(leapHand.stabilizedPalmPosition).divideScalar(20);
        yellowDot.position.copy(redDot.position).add((new THREE.Vector3()).fromArray(leapHand.direction).multiplyScalar(-1.5));
        palm.worldDirection.fromArray(leapHand.direction);
        palm.worldUp.fromArray(leapHand.palmNormal).multiplyScalar(-1);
        _ref3 = leapHand.fingers;
        for (i = _l = 0, _len3 = _ref3.length; _l < _len3; i = ++_l) {
          leapFinger = _ref3[i];
          palm.children[i].worldDirection.subVectors(leapFinger.pipPosition, leapFinger.mcpPosition).normalize();
          palm.children[i].children[0].worldDirection.subVectors(leapFinger.dipPosition, leapFinger.pipPosition).normalize();
          palm.children[i].children[0].children[0].worldDirection.subVectors(leapFinger.tipPosition, leapFinger.dipPosition).normalize();
          palm.children[i].positionFromWorld();
          palm.children[i].children[0].positionFromWorld();
          palm.children[i].children[0].children[0].positionFromWorld();
        }
        palm.worldUp.visualize();
        palm.worldDirection.visualize();
        indexFinger.worldUp.visualize();
        indexFinger.worldDirection.visualize();
        j++;
        j = j % 60;
        return renderer.render(scene, camera);
      }
    });
  });

}).call(this);
