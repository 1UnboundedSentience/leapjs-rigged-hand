// Generated by CoffeeScript 1.6.3
(function() {
  var HEIGHT, WIDTH, axis, cameraPosition, cameraPositions, pointLight, renderer, scene, showRawPositions;

  HEIGHT = window.innerHeight;

  WIDTH = window.innerWidth;

  scene = new THREE.Scene();

  renderer = new THREE.WebGLRenderer({
    alpha: true
  });

  renderer.setClearColor(0x000000, 1);

  renderer.setSize(WIDTH, HEIGHT);

  document.getElementById('threejs').appendChild(renderer.domElement);

  axis = new THREE.AxisHelper(5);

  scene.add(axis);

  scene.add(new THREE.AmbientLight(0x888888));

  pointLight = new THREE.PointLight(0xFFffff);

  pointLight.position = new THREE.Vector3(-20, 10, 0);

  pointLight.lookAt(new THREE.Vector3(0, 0, 0));

  scene.add(pointLight);

  window.camera = new THREE.PerspectiveCamera(90, WIDTH / HEIGHT, 1, 1000);

  cameraPositions = {
    back: [0, 0, -10],
    front: [0, 3, 15],
    rightSide: [25, 0, 0],
    top: [0, 14, 0]
  };

  cameraPosition = 'front';

  renderer.domElement.onclick = function() {
    camera.position.fromArray(cameraPositions[cameraPosition]);
    camera.lookAt(new THREE.Vector3(0, 0, 0));
    if (cameraPosition === 'front') {
      cameraPosition = 'back';
    } else {
      cameraPosition = 'front';
    }
    return renderer.render(scene, camera);
  };

  renderer.domElement.click();

  scene.add(camera);

  THREE.Quaternion.prototype.setFromVectors = function(a, b) {
    axis = (new THREE.Vector3).crossVectors(a, b);
    this.set(axis.x, axis.y, axis.z, 1 + a.dot(b));
    this.normalize();
    return this;
  };

  THREE.Bone.prototype.positionFromWorld = function(eye, target) {
    var angle, directionDotParentDirection;
    directionDotParentDirection = this.worldDirection.dot(this.parent.worldDirection);
    angle = Math.acos(directionDotParentDirection);
    this.worldAxis.crossVectors(this.parent.worldDirection, this.worldDirection).normalize();
    this.worldUp.set(0, 0, 0).add(this.parent.worldUp.clone().multiplyScalar(directionDotParentDirection)).add((new THREE.Vector3).crossVectors(this.worldAxis, this.parent.worldUp).multiplyScalar(Math.sin(angle))).add(this.worldAxis.clone().multiplyScalar(this.worldAxis.dot(this.parent.worldUp) * (1 - directionDotParentDirection))).normalize();
    this.matrix.lookAt(eye, target, this.worldUp);
    this.worldQuaternion.setFromRotationMatrix(this.matrix);
    this.quaternion.copy(this.parent.worldQuaternion).inverse().multiply(this.worldQuaternion);
    return this;
  };

  THREE.Vector3.prototype.fromLeap = function(array, scale) {
    this.fromArray(array).divideScalar(scale);
    return this.y -= 5;
  };

  showRawPositions = true;

  (new THREE.JSONLoader).load('javascripts/27left.json', function(geometryWithBones, materials) {
    var basicDotMesh, dots, material, rigFinger, scale, _i, _len, _ref;
    material = materials[0];
    material.skinning = true;
    window.handMesh = new THREE.SkinnedMesh(geometryWithBones, material);
    handMesh.castShadow = true;
    handMesh.receiveShadow = true;
    scene.add(handMesh);
    window.palm = handMesh.children[0];
    palm.matrixWorld = handMesh.matrix;
    palm.worldUp = new THREE.Vector3;
    _ref = palm.children;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      rigFinger = _ref[_i];
      rigFinger.mip = rigFinger.children[0];
      rigFinger.dip = rigFinger.children[0].children[0];
      rigFinger.worldQuaternion = new THREE.Quaternion;
      rigFinger.mip.worldQuaternion = new THREE.Quaternion;
      rigFinger.dip.worldQuaternion = new THREE.Quaternion;
      rigFinger.worldAxis = new THREE.Vector3;
      rigFinger.mip.worldAxis = new THREE.Vector3;
      rigFinger.dip.worldAxis = new THREE.Vector3;
      rigFinger.worldDirection = new THREE.Vector3;
      rigFinger.mip.worldDirection = new THREE.Vector3;
      rigFinger.dip.worldDirection = new THREE.Vector3;
      rigFinger.worldUp = new THREE.Vector3;
      rigFinger.mip.worldUp = new THREE.Vector3;
      rigFinger.dip.worldUp = new THREE.Vector3;
    }
    palm.worldDirection = new THREE.Vector3;
    palm.worldQuaternion = handMesh.quaternion;
    dots = {};
    basicDotMesh = new THREE.Mesh(new THREE.IcosahedronGeometry(.3, 1), new THREE.MeshNormalMaterial());
    renderer.render(scene, camera);
    scale = void 0;
    return Leap.loop(function(frame) {
      var i, leapFinger, leapHand, point, _j, _k, _len1, _len2, _ref1, _ref2;
      if ((leapHand = frame.hands[0]) && leapHand.type === 'left') {
        if (!scale) {
          scale || (scale = vec3().subVectors(leapHand.fingers[2].pipPosition3, leapHand.fingers[2].mcpPosition3).length() / palm.children[2].position.length());
        }
        palm.worldDirection.fromArray(leapHand.direction);
        palm.up.fromArray(leapHand.palmNormal).multiplyScalar(-1);
        palm.worldUp.fromArray(leapHand.palmNormal).multiplyScalar(-1);
        handMesh.position.fromLeap(leapHand.stabilizedPalmPosition, scale);
        handMesh.matrix.lookAt(palm.worldDirection, zeroVector, palm.up);
        palm.worldQuaternion.setFromRotationMatrix(handMesh.matrix);
        _ref1 = leapHand.fingers;
        for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
          leapFinger = _ref1[i];
          palm.children[i].worldDirection.subVectors(leapFinger.pipPosition3, leapFinger.mcpPosition3).normalize();
          palm.children[i].mip.worldDirection.subVectors(leapFinger.dipPosition3, leapFinger.pipPosition3).normalize();
          palm.children[i].dip.worldDirection.subVectors(leapFinger.tipPosition3, leapFinger.dipPosition3).normalize();
          palm.children[i].positionFromWorld(leapFinger.pipPosition3, leapFinger.mcpPosition3);
          palm.children[i].mip.positionFromWorld(leapFinger.dipPosition3, leapFinger.pipPosition3);
          palm.children[i].dip.positionFromWorld(leapFinger.tipPosition3, leapFinger.dipPosition3);
          if (showRawPositions) {
            _ref2 = ['mcp', 'pip', 'dip', 'tip'];
            for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
              point = _ref2[_k];
              if (!dots["" + point + "-" + i]) {
                dots["" + point + "-" + i] = basicDotMesh.clone();
                scene.add(dots["" + point + "-" + i]);
              }
              dots["" + point + "-" + i].position.fromLeap(leapFinger["" + point + "Position"], scale);
            }
          }
        }
        return renderer.render(scene, camera);
      }
    });
  });

}).call(this);
